# Day 27 - 2025/11/12

## 学んだこと

### 1. LocalStorageによるデータ永続化
- useStateの遅延初期化（lazy initialization）を使ったLocalStorageからの読み込み
- useEffectを使った自動保存機能の実装
- データの永続化により、ページをリロードしてもデータが保持される

### 2. エラーハンドリングとディフェンシブプログラミング
- LocalStorageのデータ破損時に発生するJSON.parse()エラー
- try-catchを使ったエラー処理の実装
- 外部データソース（LocalStorage）の信頼性への対処
- エラー発生時のフォールバック処理（デフォルト値の返却）

### 3. 実際に発生したエラーから学んだこと
- エラーメッセージ: "Unexpected token 'u', "function st"... is not valid JSON"
- 原因: LocalStorageに保存された破損データ（以前のテストで生じた不正なJSON）
- 教訓: 外部から読み込むデータは常に検証・エラーハンドリングが必要

## 実装した内容

### LocalStorageへの保存機能
- useStateの遅延初期化関数を使ってLocalStorageからtransactionsを読み込み
- useEffectでtransactionsの変更を監視し、自動的にLocalStorageへ保存
- ページリロード後もデータが保持されるようになった

### エラーハンドリングの必要性を理解
- LocalStorageからのデータ読み込み時にJSON.parse()エラーが発生
- try-catchでエラーをキャッチし、安全にデフォルト値を返す処理の重要性を学習

## 学習メモ

### LocalStorageの基本的な使い方

LocalStorageは、ブラウザにデータを保存するためのWeb Storage APIです。ページを閉じても、ブラウザを再起動してもデータが保持されます。

**保存するとき:**
```jsx
localStorage.setItem('キー', '値')
```

**読み込むとき:**
```jsx
const value = localStorage.getItem('キー')
```

**注意点:**
- LocalStorageは**文字列**しか保存できない
- オブジェクトや配列を保存する場合は、`JSON.stringify()`で文字列に変換
- 読み込むときは、`JSON.parse()`で元のオブジェクトや配列に戻す

### useStateの遅延初期化

通常のuseStateの初期化:
```jsx
const [transactions, setTransactions] = useState([])
```

遅延初期化を使った書き方:
```jsx
const [transactions, setTransactions] = useState(() => {
  const savedTransactions = localStorage.getItem('transactions')
  return savedTransactions ? JSON.parse(savedTransactions) : []
})
```

**遅延初期化のメリット:**
- 初期化処理が**最初の1回だけ**実行される
- コンポーネントが再レンダリングされても、無駄にLocalStorageにアクセスしない
- パフォーマンスが向上する

**通常の初期化との違い:**
```jsx
// これだと、再レンダリングのたびにLocalStorageにアクセスしてしまう（非効率）
const [transactions, setTransactions] = useState(
  JSON.parse(localStorage.getItem('transactions') || '[]')
)

// 遅延初期化なら、最初の1回だけLocalStorageにアクセス（効率的）
const [transactions, setTransactions] = useState(() => {
  return JSON.parse(localStorage.getItem('transactions') || '[]')
})
```

### useEffectによる自動保存

```jsx
useEffect(() => {
  localStorage.setItem('transactions', JSON.stringify(transactions))
}, [transactions])
```

**仕組み:**
1. `transactions`が変更されるたびにuseEffectが実行される
2. 変更された`transactions`をJSON文字列に変換
3. LocalStorageに保存

**依存配列`[transactions]`の意味:**
- transactionsが変更されたときだけ実行される
- 無駄な保存処理を防ぐ

### エラーハンドリングの重要性

**エラーが発生したコード（問題のあるバージョン）:**
```jsx
const [transactions, setTransactions] = useState(() => {
  const savedTransactions = localStorage.getItem('transactions')
  return savedTransactions ? JSON.parse(savedTransactions) : []
})
```

**問題点:**
- LocalStorageに破損したデータがあるとJSON.parse()でエラーが発生
- エラーをキャッチしないと、アプリ全体がクラッシュしてしまう

**改善版（エラーハンドリングあり）:**
```jsx
const [transactions, setTransactions] = useState(() => {
  try {
    const savedTransactions = localStorage.getItem('transactions')
    return savedTransactions ? JSON.parse(savedTransactions) : []
  } catch (error) {
    console.error('LocalStorageの読み込みエラー:', error)
    return [] // エラー時は空配列を返す
  }
})
```

**try-catchの役割:**
- エラーが発生しても、アプリがクラッシュしない
- エラーをログに記録して、原因を調査できる
- フォールバック処理（デフォルト値を返す）で、アプリを継続して動作させる

### ディフェンシブプログラミングとは

外部から受け取るデータ（LocalStorage、API、ユーザー入力など）は**常に信頼できない**という前提でコードを書くこと。

**ディフェンシブプログラミングの原則:**
1. **データを検証する**: 想定外のデータが来ても対処できるようにする
2. **エラーハンドリング**: try-catchでエラーを適切に処理する
3. **フォールバック**: エラー時のデフォルト動作を用意する
4. **ログを記録**: エラーの原因を調査できるようにする

**なぜ重要か:**
- 実際の開発では、予想外のデータやエラーが必ず発生する
- ユーザーがアプリを使い続けられるようにする
- バグの原因を特定しやすくなる

### LocalStorageのデータ破損が起こる理由

今回のエラーの原因:
- 以前のテストで、誤ったデータがLocalStorageに保存されていた
- そのデータをJSON.parse()しようとして失敗

**データ破損の原因例:**
- 開発中のコード変更で、データ構造が変わった
- 手動でLocalStorageを編集した
- ブラウザの拡張機能が干渉した
- 保存処理の途中でエラーが発生した

**対策:**
- try-catchでエラーをキャッチ
- データのバージョン管理（将来的な対応）
- 開発者ツールでLocalStorageを確認・クリアする方法を知っておく

### LocalStorageのデバッグ方法

**ブラウザの開発者ツールで確認:**
1. F12キーで開発者ツールを開く
2. "Application"タブ（ChromeやEdge）または"Storage"タブ（Firefox）を選択
3. 左サイドバーの"Local Storage"を展開
4. 保存されているデータを確認・編集・削除できる

**プログラムでクリアする:**
```jsx
localStorage.clear() // すべてのデータを削除
localStorage.removeItem('transactions') // 特定のキーだけ削除
```

## コード例

### 実装したLocalStorage機能の全体像

```jsx
import { useEffect, useState } from "react"

function App(){
  // 遅延初期化でLocalStorageからデータを読み込む
  const [transactions, setTransactions] = useState(() => {
    const savedTransactions = localStorage.getItem('transactions')
    return savedTransactions ? JSON.parse(savedTransactions) : []
  })

  // transactionsが変更されるたびに自動保存
  useEffect(() => {
    localStorage.setItem('transactions', JSON.stringify(transactions))
  }, [transactions])

  // 以降、通常の処理...
}
```

### エラーハンドリング付きバージョン（推奨）

```jsx
import { useEffect, useState } from "react"

function App(){
  // エラーハンドリング付きの遅延初期化
  const [transactions, setTransactions] = useState(() => {
    try {
      const savedTransactions = localStorage.getItem('transactions')
      return savedTransactions ? JSON.parse(savedTransactions) : []
    } catch (error) {
      console.error('LocalStorageの読み込みに失敗しました:', error)
      // エラー時は空配列を返してアプリを継続
      return []
    }
  })

  // 自動保存（こちらも念のためtry-catchを追加すると更に安全）
  useEffect(() => {
    try {
      localStorage.setItem('transactions', JSON.stringify(transactions))
    } catch (error) {
      console.error('LocalStorageへの保存に失敗しました:', error)
    }
  }, [transactions])

  // 以降、通常の処理...
}
```

## 次のステップ

- [ ] エラーハンドリングを追加してコミット（try-catchの実装）
- [ ] CSSスタイリングの実装
  - フォームのデザイン改善
  - 取引履歴のレイアウト調整
  - レスポンシブデザイン対応
- [ ] 家計簿アプリの完成とデプロイ
- [ ] 次のお題（Phase 3 - お題6以降）に進む

## その他のメモ

### 今日のセッションのハイライト

今回の学習で特に重要だったのは、**実際にエラーに遭遇して、その解決方法を学べたこと**です。

教科書的な知識だけでなく、実際の開発でよくある問題（LocalStorageの破損データ）に対処する方法を体験できました。これは実践的なスキルとして非常に価値があります。

**学んだ実践的スキル:**
- エラーメッセージから原因を推測する
- try-catchでエラーを安全に処理する
- フォールバック処理でアプリの可用性を維持する
- 開発者ツールでLocalStorageをデバッグする

エラーは学習の大きなチャンスです。今回のように、エラーから学ぶことで、より堅牢なコードを書けるようになります。

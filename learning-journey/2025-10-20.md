# Day 5 - 2025/10/20

## 学んだこと

### 1. useEffectフック
- コンポーネントの副作用（side effect）を扱うフック
- レンダリング後に実行される処理を記述
- 依存配列で実行タイミングを制御
- `useEffect(() => { 処理 }, [依存変数])`

### 2. LocalStorage API
- ブラウザにデータを保存する仕組み
- `localStorage.setItem(key, value)` でデータを保存
- `localStorage.getItem(key)` でデータを取得
- ページリロード後もデータが残る

### 3. JSON変換
- `JSON.stringify()`: オブジェクト → 文字列に変換
- `JSON.parse()`: 文字列 → オブジェクトに変換
- LocalStorageは文字列しか保存できないため必要

### 4. useState の初期化関数
- `useState(() => { ... })` の形式
- 初回レンダリング時のみ実行される
- 重い処理を遅延させるために使う

### 5. 配列メソッドの復習
- **map**: 全要素を変換して新しい配列を作る
- **filter**: 条件に合う要素を抽出
- **スプレッド構文**: `...` で配列を展開

## 実装した内容
- LocalStorageでのデータ永続化
- useEffectでの自動保存
- 起動時にLocalStorageから読み込み

## 学習メモ

### useEffect の基本

```jsx
useEffect(() => {
  // todosが変更されるたびに実行される
  localStorage.setItem("todos", JSON.stringify(todos))
}, [todos])  // 依存配列
```

**仕組み:**
1. `todos`が変更される
2. コンポーネントが再レンダリングされる
3. レンダリング後に`useEffect`内の処理が実行される
4. LocalStorageに保存

### LocalStorageへの保存

```jsx
// オブジェクトを文字列に変換して保存
localStorage.setItem("todos", JSON.stringify(todos))

// 例:
todos = [{ id: 1, text: "買い物", completed: false }]
↓ JSON.stringify
"[{\"id\":1,\"text\":\"買い物\",\"completed\":false}]"
```

### LocalStorageから読み込み

```jsx
const [todos, setTodos] = useState(() => {
  const savedTodos = localStorage.getItem("todos")
  if (savedTodos) {
    return JSON.parse(savedTodos)  // 文字列 → オブジェクト
  }
  return []  // 保存データがなければ空配列
})
```

**実行タイミング:**
- この関数は**最初の1回だけ**実行される
- 2回目以降のレンダリングでは実行されない

### データの流れ

```
【起動時】
LocalStorage → getItem → JSON.parse → useState初期値
                                         ↓
                                      todos配列

【ToDo操作時】
ユーザー操作 → setTodos → todos更新 → 再レンダリング
                                         ↓
                                    useEffect発火
                                         ↓
                              JSON.stringify → setItem
                                         ↓
                                   LocalStorageに保存
```

## 理解した概念

### useEffectの依存配列

```jsx
useEffect(() => {
  // 処理
}, [todos])
```

- `[todos]`: todosが変わった時だけ実行
- `[]`: 初回レンダリング時のみ実行
- 依存配列なし: 毎回のレンダリング後に実行

### なぜJSON変換が必要？

LocalStorageは**文字列しか保存できない**ため。

```jsx
// ❌ これはできない
localStorage.setItem("todos", todos)  // [object Object] になる

// ✅ JSON文字列に変換
localStorage.setItem("todos", JSON.stringify(todos))
```

### mapの使い方

```jsx
const newTodos = todos.map((todo) => {
  if (todo.id === id) {
    return {...todo, completed: !todo.completed}  // 該当ToDoを変更
  }
  return todo  // それ以外はそのまま
})
```

**全てのToDoをチェックして、該当するものだけ変更した新しい配列を返す**

### スプレッド構文

```jsx
[...todos, newTodo]  // todosを展開して、最後にnewTodoを追加
```

**spread = 広げる、展開する**という意味。

## 新しく学んだ用語

- **副作用（side effect）**: レンダリング以外の処理（データ取得、保存など）
- **依存配列（dependency array）**: useEffectの実行タイミングを制御する配列
- **シリアライズ**: データを文字列に変換すること（JSON.stringify）
- **デシリアライズ**: 文字列をデータに復元すること（JSON.parse）
- **永続化**: データを保存して次回も使えるようにすること

## その他の作業

- コードの各部分について質問して理解を深めた
- mapとfilterの違いを復習
- スプレッド構文の意味を確認
- 条件付きレンダリングの復習

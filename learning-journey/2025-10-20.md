# Day 5 - 2025/10/20

## 学んだこと

### 1. useEffectフック
- コンポーネントの副作用（side effect）を扱うフック
- レンダリング後に実行される処理を記述
- 依存配列で実行タイミングを制御
- `useEffect(() => { 処理 }, [依存変数])`

### 2. LocalStorage API
- ブラウザにデータを保存する仕組み
- `localStorage.setItem(key, value)` でデータを保存
- `localStorage.getItem(key)` でデータを取得
- ページリロード後もデータが残る

### 3. JSON変換
- `JSON.stringify()`: オブジェクト → 文字列に変換
- `JSON.parse()`: 文字列 → オブジェクトに変換
- LocalStorageは文字列しか保存できないため必要

### 4. useState の初期化関数
- `useState(() => { ... })` の形式
- 初回レンダリング時のみ実行される
- 重い処理を遅延させるために使う

### 5. 配列メソッドの復習
- **map**: 全要素を変換して新しい配列を作る
- **filter**: 条件に合う要素を抽出
- **スプレッド構文**: `...` で配列を展開

## 実装した内容
- LocalStorageでのデータ永続化
- useEffectでの自動保存
- 起動時にLocalStorageから読み込み

## 学習メモ

### useEffect の基本

```jsx
useEffect(() => {
  // todosが変更されるたびに実行される
  localStorage.setItem("todos", JSON.stringify(todos))
}, [todos])  // 依存配列
```

**仕組み:**
1. `todos`が変更される
2. コンポーネントが再レンダリングされる
3. レンダリング後に`useEffect`内の処理が実行される
4. LocalStorageに保存

### LocalStorageへの保存

```jsx
// オブジェクトを文字列に変換して保存
localStorage.setItem("todos", JSON.stringify(todos))

// 例:
todos = [{ id: 1, text: "買い物", completed: false }]
↓ JSON.stringify
"[{\"id\":1,\"text\":\"買い物\",\"completed\":false}]"
```

### LocalStorageから読み込み

```jsx
const [todos, setTodos] = useState(() => {
  const savedTodos = localStorage.getItem("todos")
  if (savedTodos) {
    return JSON.parse(savedTodos)  // 文字列 → オブジェクト
  }
  return []  // 保存データがなければ空配列
})
```

**実行タイミング:**
- この関数は**最初の1回だけ**実行される
- 2回目以降のレンダリングでは実行されない

### データの流れ

```
【起動時】
LocalStorage → getItem → JSON.parse → useState初期値
                                         ↓
                                      todos配列

【ToDo操作時】
ユーザー操作 → setTodos → todos更新 → 再レンダリング
                                         ↓
                                    useEffect発火
                                         ↓
                              JSON.stringify → setItem
                                         ↓
                                   LocalStorageに保存
```

## 理解した概念

### useEffectの依存配列

```jsx
useEffect(() => {
  // 処理
}, [todos])
```

- `[todos]`: todosが変わった時だけ実行
- `[]`: 初回レンダリング時のみ実行
- 依存配列なし: 毎回のレンダリング後に実行

### なぜJSON変換が必要？

LocalStorageは**文字列しか保存できない**ため。

```jsx
// ❌ これはできない
localStorage.setItem("todos", todos)  // [object Object] になる

// ✅ JSON文字列に変換
localStorage.setItem("todos", JSON.stringify(todos))
```

### mapの使い方

```jsx
const newTodos = todos.map((todo) => {
  if (todo.id === id) {
    return {...todo, completed: !todo.completed}  // 該当ToDoを変更
  }
  return todo  // それ以外はそのまま
})
```

**全てのToDoをチェックして、該当するものだけ変更した新しい配列を返す**

### スプレッド構文

```jsx
[...todos, newTodo]  // todosを展開して、最後にnewTodoを追加
```

**spread = 広げる、展開する**という意味。

## 新しく学んだ用語

- **副作用（side effect）**: レンダリング以外の処理（データ取得、保存など）
- **依存配列（dependency array）**: useEffectの実行タイミングを制御する配列
- **シリアライズ**: データを文字列に変換すること（JSON.stringify）
- **デシリアライズ**: 文字列をデータに復元すること（JSON.parse）
- **永続化**: データを保存して次回も使えるようにすること

## その他の作業

- コードの各部分について質問して理解を深めた
- mapとfilterの違いを復習
- スプレッド構文の意味を確認
- 条件付きレンダリングの復習

(Session 2)

## 学んだこと

### 1. filterメソッドの応用
- 条件に合う要素だけを抽出して新しい配列を作る
- `todos.filter((todo) => !todo.completed)` で未完了のToDoだけ抽出
- `todos.filter((todo) => todo.completed)` で完了済みのToDoだけ抽出

### 2. 否定演算子 `!`
- `!` は「〜でない」という意味
- `!todo.completed` = completedがfalseのもの
- `!true` → `false`、`!false` → `true`

### 3. テンプレートリテラル
- バッククォート（`` ` ``）で文字列の中に式を埋め込める
- `` `filter-tab ${filter === "all" ? "active" : ""}` ``
- 動的にクラス名を変更できる

### 4. 計算値とstateの使い分け
- 他のstateから計算できる値は**stateにしない**
- `filteredTodos`は`todos`と`filter`から計算できるので、stateにする必要なし
- `const filteredTodos = getFilteredTodos()` で毎回計算

### 5. 関数の分割
- 複雑な処理は関数に分けると読みやすい
- `getFilteredTodos()` 関数でフィルタリング処理を分離
- コードの可読性と再利用性が向上

## 実装した内容
- フィルター機能（全て/未完了/完了）
- タブUI
- アクティブなタブの視覚的な表示

## 学習メモ

### filterのstate管理

```jsx
const [filter, setFilter] = useState("all")
```

**管理する値:**
- `"all"`: 全て表示
- `"active"`: 未完了のみ表示
- `"completed"`: 完了済みのみ表示

### getFilteredTodos関数

```jsx
const getFilteredTodos = () => {
  if (filter === "active") {
    return todos.filter((todo) => !todo.completed)  // 未完了のみ
  }
  if (filter === "completed") {
    return todos.filter((todo) => todo.completed)   // 完了済みのみ
  }
  return todos  // 全て
}
```

**役割:** 現在のfilter設定に応じて表示するToDoをフィルタリング

### フィルタリングの仕組み

```jsx
// 未完了のみ（active）
todos.filter((todo) => !todo.completed)

// 例:
[
  { id: 1, text: "買い物", completed: false },  // ← 残る
  { id: 2, text: "勉強", completed: true },     // 除外
  { id: 3, text: "掃除", completed: false }     // ← 残る
]
↓
[
  { id: 1, text: "買い物", completed: false },
  { id: 3, text: "掃除", completed: false }
]
```

### タブUIの実装

```jsx
<button
  className={`filter-tab ${filter === "all" ? "active" : ""}`}
  onClick={() => setFilter("all")}
>
  全て
</button>
```

**classNameの動的設定:**
- `filter === "all"` が `true` → `"filter-tab active"`
- `filter === "all"` が `false` → `"filter-tab"`

### テンプレートリテラルの使い方

```jsx
// バッククォート（`）で囲む
`文字列 ${式} 文字列`

// 例:
const name = "Akihiko"
`Hello ${name}!`  // "Hello Akihiko!"

// 三項演算子も使える
`filter-tab ${filter === "all" ? "active" : ""}`
```

### filteredTodos変数

```jsx
const filteredTodos = getFilteredTodos()
```

**なぜ変数に入れる？**
- 関数を1回だけ実行するため（効率化）
- コードが読みやすくなる

**なぜstateにしない？**
- `todos`と`filter`から計算できるから
- 他のstateから計算できる値はstateにしないのが原則

### リスト表示の変更

```jsx
// 変更前: 全てのToDoを表示
{todos.map((todo) => (

// 変更後: フィルタリング済みのToDoを表示
{filteredTodos.map((todo) => (
```

## データの流れ

### タブをクリックした時

```
1. ユーザーが「未完了」タブをクリック
   ↓
2. onClick={() => setFilter("active")} が実行
   ↓
3. filter が "active" に変更
   ↓
4. コンポーネントが再レンダリング
   ↓
5. getFilteredTodos() が再実行される
   ↓
6. todos.filter((todo) => !todo.completed) で未完了のToDoだけ抽出
   ↓
7. filteredTodos に未完了のToDoが入る
   ↓
8. 画面に未完了のToDoだけが表示される
```

### ToDoにチェックを入れた時

```
1. チェックボックスをクリック
   ↓
2. toggleTodo(id) が実行
   ↓
3. todos が更新される（completedが反転）
   ↓
4. 再レンダリング
   ↓
5. getFilteredTodos() が再実行
   ↓
6. フィルタリング結果が更新
   ↓
7. 表示が更新される（例: 完了したToDoが「未完了」タブから消える）
```

## CSSのポイント

### タブのレイアウト

```css
.filter-tabs {
  display: flex;           /* 横並び */
  gap: 0.5rem;            /* ボタン間の隙間 */
  border-bottom: 2px solid #e0e0e0;  /* 下線 */
}
```

### アクティブなタブ

```css
.filter-tab.active {
  color: #4CAF50;                    /* 緑色の文字 */
  border-bottom-color: #4CAF50;      /* 緑色の下線 */
  font-weight: 600;                  /* 太字 */
}
```

**`.filter-tab.active`** = `filter-tab`クラスと`active`クラスの両方を持つ要素

## 理解した概念

### filterとmapの違い

| メソッド | やること | 要素数 |
|---------|---------|--------|
| **filter** | 条件に合う要素を抽出 | 減る可能性がある |
| **map** | 全要素を変換 | 変わらない |

```jsx
// filter: 条件に合うものだけ残す
[1, 2, 3, 4, 5].filter(x => x > 3)  // [4, 5]

// map: 全要素を変換
[1, 2, 3].map(x => x * 2)  // [2, 4, 6]
```

### stateにすべきもの・すべきでないもの

**stateにする:**
- ユーザーの入力値
- 選択状態
- 他から計算できない値

**stateにしない:**
- 他のstateから計算できる値
- 固定値

```jsx
// ✅ stateにする
const [todos, setTodos] = useState([])
const [filter, setFilter] = useState("all")

// ❌ stateにしない（計算で求められる）
const filteredTodos = getFilteredTodos()
```

## トラブルシューティング

### 発生したエラー

1. **70行目・73行目**: `todo.filter` → `todos.filter`
   - 配列名のタイポ

2. **App.css 209行目**: `.filter-tab.cancel-button:active` → `.filter-tab.active`
   - クラス名のタイポ

### 学んだこと
- filterメソッドは配列に対して使う（`todos.filter`）
- CSSのクラスセレクタは正確に（`.filter-tab.active`）
- タイポに注意

## 新しく学んだ用語

- **フィルタリング**: 条件に合うデータだけを抽出すること
- **テンプレートリテラル**: バッククォートで囲んだ文字列（`` `...` ``）
- **否定演算子**: `!` で真偽値を反転
- **計算値**: 他の値から計算で求められる値
- **動的クラス名**: 条件によって変わるクラス名

## その他の作業

- 並行レンダリング（Concurrent Rendering）について学習
- main.jsxの`createRoot`の意味を理解
- React 18の新機能について理解

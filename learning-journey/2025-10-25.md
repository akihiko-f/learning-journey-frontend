# Day 7 - 2025/10/25

## 学んだこと

### 1. プロジェクト構成の変更
- 複数のアプリを管理するためにディレクトリを分割
- 各アプリが完全に独立したプロジェクトになった
- ルートディレクトリから重複ファイルを削除

### 2. カウントダウンタイマーの実装（Phase 2-1）
- 時間入力機能（分・秒）
- MM:SS形式での時間表示
- 時間切れメッセージ
- タイマー実行中の入力無効化

## 実装した内容

### プロジェクト構成の変更
```
learning-journey-frontend/
├── todo-app/              # ToDoアプリ（Phase 1完了）
├── timer-app/             # カウントダウンタイマー（Phase 2-1）
├── assignments/           # お題の仕様書
├── learning-journey/      # 学習記録
└── README.md
```

### カウントダウンタイマーの機能
- ✅ 時間設定の入力欄（分・秒）
- ✅ MM:SS形式での残り時間表示
- ✅ カウントダウン機能（1秒ごとに減少）
- ✅ スタート/ストップ/リセットボタン
- ✅ 時間切れメッセージ表示
- ✅ タイマー実行中の入力欄無効化

## 学習メモ

### 1. プロジェクト構成の設計

**複数アプリを管理する方法:**
- 各アプリを独立したディレクトリに分ける
- それぞれが独自の`package.json`、`vite.config.js`を持つ
- 起動時にディレクトリを移動して実行

**メリット:**
- 依存関係が混ざらない
- 設定が独立している
- 管理がシンプル

```bash
# ToDoアプリ起動
cd todo-app
npm run dev

# Timerアプリ起動
cd timer-app
npm run dev
```

### 2. 時間入力機能

#### State管理
```jsx
const [minutes, setMinutes] = useState(0)  // 分の入力値
const [seconds, setSeconds] = useState(0)  // 秒の入力値
```

#### 入力欄の実装
```jsx
<input
  type="number"
  min="0"
  max="59"
  value={minutes}
  onChange={(e) => setMinutes(Number(e.target.value))}
  disabled={isRunning}  // 実行中は無効化
/>
```

**ポイント:**
- `type="number"` - 数値入力
- `min`と`max` - 入力範囲を制限
- `Number(e.target.value)` - 文字列を数値に変換
- `disabled={isRunning}` - 条件付きで無効化

### 3. 時間の変換処理

#### 分と秒を合計秒数に変換
```jsx
const pushStart = () => {
  if (elapsedTime === 0) {
    const totalSeconds = minutes * 60 + seconds
    setElapsedTime(totalSeconds)
  }
  setIsRunning(true)
}
```

**計算式:**
- `分 × 60 + 秒 = 合計秒数`
- 例: 5分30秒 → 5 × 60 + 30 = 330秒

#### 秒数をMM:SS形式に変換
```jsx
const formatTime = (totalSeconds) => {
  const mins = Math.floor(totalSeconds / 60)
  const secs = totalSeconds % 60
  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
}
```

**計算式:**
- `Math.floor(秒数 / 60)` - 分を計算（小数点切り捨て）
- `秒数 % 60` - 残りの秒を計算（余り）
- 例: 330秒 → 5分30秒

**文字列フォーマット:**
- `String(mins)` - 数値を文字列に変換
- `.padStart(2, '0')` - 2桁に揃える（1桁なら0を前に追加）
- 例: `5` → `"05"`, `30` → `"30"`

### 4. 条件付きレンダリング（時間切れメッセージ）

```jsx
{elapsedTime === 0 && !isRunning && (
  <div className="timeout-message">時間切れ！</div>
)}
```

**条件:**
- `elapsedTime === 0` - 残り時間が0秒
- `!isRunning` - タイマーが停止中
- 両方が`true`の時だけメッセージを表示

**なぜ`!isRunning`が必要？**
- タイマーが0秒でも、まだ実行中の瞬間がある
- 完全に停止してからメッセージを表示する

### 5. Props の流れ

```
App.jsx（親）
  ├─ minutes, seconds (入力値のstate)
  ├─ setMinutes, setSeconds (state更新関数)
  ├─ elapsedTime, isRunning (タイマーのstate)
  └─ pushStart, pushStop, resetTimer (操作関数)
       ↓ Props
Timer.jsx（子）
  ├─ 入力欄で minutes, seconds を表示・変更
  ├─ formatTime で elapsedTime を表示
  └─ ボタンで関数を実行
```

**データフロー:**
1. ユーザーが入力欄に入力 → `setMinutes`/`setSeconds`で親のstateを更新
2. 開始ボタンクリック → `pushStart`で分と秒を秒数に変換
3. useEffectで1秒ごとに`elapsedTime`を減らす
4. Timerコンポーネントで`formatTime`を使って表示

## 新しく学んだ用語・概念

### JavaScript

- **Math.floor()** - 小数点を切り捨てて整数にする関数
- **% (モジュロ演算子)** - 割り算の余りを求める
- **padStart()** - 文字列の先頭に指定文字を追加して指定桁数にする
- **Number()** - 文字列を数値に変換する関数

### React

- **disabled属性** - 条件付きでフォーム要素を無効化
- **条件付きレンダリング (&&)** - 条件が`true`の時だけ要素を表示
- **type="number"** - 数値入力用のinput要素

## コードの理解

### 1. formatTime関数の仕組み

```jsx
const formatTime = (totalSeconds) => {
  const mins = Math.floor(totalSeconds / 60)
  const secs = totalSeconds % 60
  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
}
```

**例: 330秒の場合**
1. `mins = Math.floor(330 / 60) = Math.floor(5.5) = 5`
2. `secs = 330 % 60 = 30` （330 ÷ 60 = 5 余り 30）
3. `String(5).padStart(2, '0')` → `"05"`
4. `String(30).padStart(2, '0')` → `"30"`
5. 結果: `"05:30"`

### 2. pushStart関数の処理

```jsx
const pushStart = () => {
  if (elapsedTime === 0) {
    const totalSeconds = minutes * 60 + seconds
    setElapsedTime(totalSeconds)
  }
  setIsRunning(true)
}
```

**処理の流れ:**
1. `elapsedTime === 0`をチェック（初回起動または完全リセット後）
2. 分と秒を合計秒数に変換
3. `setElapsedTime`で秒数をセット
4. `setIsRunning(true)`でタイマー開始

**なぜ`if (elapsedTime === 0)`？**
- 一時停止後の再開時は、残り時間をそのまま使いたい
- 0の時だけ、入力値から新しく計算する

### 3. 入力欄の無効化

```jsx
<input
  disabled={isRunning}
/>
```

**動作:**
- `isRunning === true` → 入力欄が無効（グレーアウト）
- `isRunning === false` → 入力欄が有効

**理由:**
- タイマー実行中に入力値を変更されると困る
- 停止/リセット後に入力できるようにする

## Phase 2-1 の達成状況

✅ **カウントダウンタイマー完成！**

- ✅ 時間設定（分・秒）
- ✅ スタート/ストップ/リセット
- ✅ MM:SS形式での表示
- ✅ 時間切れの通知
- ✅ タイマー実行中の入力無効化

**Phase 2（実践フェーズ）の最初のお題をクリアしました！**

## 今日の作業内容

1. プロジェクト構成をリファクタリング
   - todo-app/とtimer-app/に分割
   - 古いファイルを削除
   - README.mdを更新

2. カウントダウンタイマーを実装（写経）
   - 時間入力欄の追加
   - formatTime関数の実装
   - 時間切れメッセージの表示

3. Gitにコミット・プッシュ

## まとめ

### 学んだ重要な概念

1. **プロジェクト構成** - 複数アプリの管理方法
2. **数値変換** - 分・秒 ⇄ 秒数の相互変換
3. **文字列フォーマット** - padStartで桁揃え
4. **条件付き無効化** - disabledとisRunningの組み合わせ
5. **Math.floor() と %** - 時間計算に必須の演算

### 次のステップ

**Phase 2-2: 簡易計算機**
- 次のお題に挑戦
- 今回学んだ知識を活かす

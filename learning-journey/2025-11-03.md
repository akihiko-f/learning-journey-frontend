# Day 9 - 2025/11/03

## 学んだこと

### 1. 配列とmap関数を使った効率的なUIの生成
- **1次元配列 + CSSグリッド vs 2次元配列**:
  - 1次元配列 + CSSグリッド: データとレイアウトの関心を分離（推奨）
  - 2次元配列: データ構造にレイアウトが含まれる（結合度が高い）
- **map関数によるボタン生成**:
  ```jsx
  const buttons = [7, 8, 9, '/', 4, 5, 6, '*', 1, 2, 3, '-', 0, 'C', '=', '+']

  {buttons.map((btn, index) => (
    <button key={index} onClick={() => handleButtonClick(btn)}>
      {btn}
    </button>
  ))}
  ```
  - 配列の各要素に対してJSXを生成
  - `key`プロパティで各要素を一意に識別（Reactの要件）

### 2. JavaScript構文の理解
- **typeof演算子**: 値の型を判定
  ```jsx
  if (typeof btn === 'number') {
    // 数字ボタンの処理
  }
  ```
- **includes()メソッド**: 配列に特定の値が含まれるか判定
  ```jsx
  if (['+', '-', '*', '/'].includes(btn)) {
    // 演算子ボタンの処理
  }
  ```
- **三項演算子**: 条件に応じた値の選択
  ```jsx
  display === '0' ? String(number) : display + number
  ```
- **parseFloat()**: 文字列を浮動小数点数に変換

### 3. 計算機の状態遷移ロジック
- **数字入力時の動作**:
  - `shouldResetDisplay`フラグで表示のリセット判定
  - 演算子クリック後は新しい数字で表示をリセット
  - それ以外は既存の表示に数字を追加
- **演算子クリック時の動作**:
  1. `firstValue`がnullの場合: 現在の値を保存
  2. `firstValue`があり`operator`も設定済みの場合: 連続計算を実行
  3. 新しい演算子を設定し、`shouldResetDisplay`をtrueに
- **イコールクリック時の動作**:
  1. `firstValue`と`operator`が存在することを確認
  2. 計算を実行して結果を表示
  3. 状態をリセット（`firstValue`と`operator`をnull、`shouldResetDisplay`をtrueに）
- **連続計算の処理**:
  - 「5 + 3 + 2」のような連続計算が可能
  - 2つ目の演算子を押した時点で1つ目の計算を実行
  - 結果を`firstValue`に保存して次の計算に備える

### 4. イベントハンドラーの設計パターン
- **統一されたクリックハンドラー**: `handleButtonClick(btn)`
  - ボタンの種類（数字/演算子/特殊ボタン）を判定
  - 適切なハンドラー関数に処理を委譲
- **役割分担**:
  - `handleNumberClick()`: 数字ボタンの処理
  - `handleOperatorClick()`: 演算子ボタンの処理
  - `handleEqualsClick()`: イコールボタンの処理
  - クリアボタンはhandleButtonClick内で直接処理

### 5. switch文を使った計算ロジック
- **calculate関数**: 演算子に応じた計算を実行
  ```jsx
  const calculate = (a, b, op) => {
    switch (op) {
      case '+': return a + b
      case '-': return a - b
      case '*': return a * b
      case '/': return b !== 0 ? a / b : 0
      default: return b
    }
  }
  ```
- **ゼロ除算の処理**: `b !== 0 ? a / b : 0`でエラーを回避

### 6. CSSのimportとグリッドレイアウト
- **CSSファイルのimport**: `import './App.css'`でスタイルを適用
- **CSS Gridによるボタン配置**:
  ```css
  .buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
  }
  ```
  - `repeat(4, 1fr)`: 4列の均等幅グリッド
  - `gap: 8px`: グリッドアイテム間の隙間

### 7. デバッグ経験
- **無限ループの発生と解決**:
  - 問題: 演算子クリック時に無限ループが発生
  - 原因の特定プロセス（推測）
  - 解決策の実装

## 実装した内容

### 1. 数字入力機能
- `handleNumberClick(number)`関数の実装
- `shouldResetDisplay`フラグによる表示制御
- 初期値'0'からの適切な遷移処理

### 2. 四則演算機能
- `handleOperatorClick(op)`関数の実装
- 連続計算のサポート（例: 5 + 3 + 2）
- 演算子選択時の状態更新

### 3. 計算実行機能
- `handleEqualsClick()`関数の実装
- `calculate(a, b, op)`関数による演算処理
- ゼロ除算エラーの防止

### 4. クリア機能
- Cボタンクリック時に全ての状態をリセット
- 初期状態（'0'表示）への復帰

### 5. 効率的なボタン生成
- 1次元配列`buttons`の定義
- `map`関数による動的なボタン要素生成
- 統一されたクリックハンドラーの実装

### 6. レイアウトとスタイリング
- CSSグリッドによる4×4のボタン配置
- ディスプレイエリアのスタイリング（黒背景、白文字、右寄せ）
- ボタンのホバー効果の実装

## 学習メモ

### 関心の分離: 1次元配列 + CSSグリッド

**1次元配列 + CSSグリッドのアプローチ（採用）**:
```jsx
const buttons = [7, 8, 9, '/', 4, 5, 6, '*', 1, 2, 3, '-', 0, 'C', '=', '+']
```
```css
.buttons {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
}
```

利点:
- データ（ボタンの値）とレイアウト（配置）が分離
- レイアウト変更時にJavaScriptを触る必要がない
- データ構造がシンプルで理解しやすい

**2次元配列のアプローチ（不採用）**:
```jsx
const buttons = [
  [7, 8, 9, '/'],
  [4, 5, 6, '*'],
  // ...
]
```

欠点:
- データ構造にレイアウト情報が含まれる
- 関心の分離の原則に反する

### 計算機の状態管理フロー

```jsx
// 初期状態
display: '0'
firstValue: null
operator: null
shouldResetDisplay: false

// ユーザーが「5」を入力
→ display: '5'

// ユーザーが「+」を押す
→ firstValue: 5
→ operator: '+'
→ shouldResetDisplay: true

// ユーザーが「3」を入力
→ display: '3' (shouldResetDisplayがtrueなのでリセット)
→ shouldResetDisplay: false

// ユーザーが「=」を押す
→ display: '8' (5 + 3の結果)
→ firstValue: null
→ operator: null
→ shouldResetDisplay: true
```

### 連続計算の実装

```jsx
const handleOperatorClick = (op) => {
  const currentValue = parseFloat(display)

  if (firstValue === null) {
    // 最初の演算子: 現在の値を保存
    setFirstValue(currentValue)
  } else if (operator) {
    // 2つ目以降の演算子: 直前の計算を実行
    const result = calculate(firstValue, currentValue, operator)
    setDisplay(String(result))
    setFirstValue(result)  // 結果を次の計算の最初の値に
  }

  setOperator(op)
  setShouldResetDisplay(true)
}
```

このロジックにより「5 + 3 + 2 =」のような連続計算が可能:
1. 「5」入力 → display: '5'
2. 「+」押す → firstValue: 5, operator: '+'
3. 「3」入力 → display: '3'
4. 「+」押す → 5+3を計算してdisplay: '8', firstValue: 8, operator: '+'
5. 「2」入力 → display: '2'
6. 「=」押す → 8+2を計算してdisplay: '10'

### デバッグ経験

無限ループの問題に遭遇し、解決した経験:
- 問題の発生状況を正確に把握
- 原因の推測と仮説立て
- コードの修正
- 動作確認とテスト

このデバッグ経験を通じて、エラーに対する対処方法を学んだ。

## その他の作業

### コードの整理とリファクタリング
- イベントハンドラーを役割ごとに分離
- calculate関数を独立した関数として実装
- コードの可読性向上

### 完成した計算機の機能確認
- 四則演算（+、-、*、/）の動作確認
- 連続計算の動作確認
- クリア機能の動作確認
- ゼロ除算の防止確認

### 次のステップ
- 計算機アプリは基本機能が完成
- 次の学習課題（フェーズ1-3など）に進む準備が整った

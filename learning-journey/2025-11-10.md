# Day 25 - 2025/11/10

## 学んだこと

### 1. filter()とreduce()の組み合わせによるデータ集計
- filter()で条件に合うデータを絞り込み
- reduce()で絞り込んだデータの合計値を計算
- メソッドチェーンによる処理の組み立て方

### 2. reduce()メソッドの使い方
- 配列の要素を1つの値にまとめるメソッド
- 第1引数: コールバック関数（累積値, 現在の値）
- 第2引数: 初期値（合計計算の場合は0）
- 累積値を返していくことで合計を計算

### 3. toLocaleString()による数値フォーマット
- 数値を3桁区切りで表示（例: 1000 → 1,000）
- 金額表示を見やすくするための標準的な方法
- 桁数が多くても自動的にカンマが入る

### 4. 複数の計算結果を変数に格納して再利用
- totalIncome、totalExpense、balanceを変数として定義
- JSX内で複数回使用できる
- 計算ロジックとUIの分離

## 実装した内容

### お題5: 簡易家計簿アプリ - サマリー表示と計算機能

#### 今日実装した機能:
- ✅ 収入の合計金額計算（filter + reduce）
- ✅ 支出の合計金額計算（filter + reduce）
- ✅ 残高の計算（収入 - 支出）
- ✅ サマリー表示UI（収入、支出、残高の3つの表示エリア）
- ✅ 金額の3桁区切り表示（toLocaleString）
- ✅ 収入/支出の符号表示（+/-）

#### 全体の進捗:
1. ✅ プロジェクトセットアップ
2. ✅ 基本UI実装（入力フォーム）
3. ✅ 取引記録機能（追加・削除）
4. ✅ カテゴリ分類
5. ✅ 合計金額計算（収入合計、支出合計、残高）
6. ⏳ 月ごとの表示フィルタリング（未実装）
7. ⏳ LocalStorageでの永続化（未実装）
8. ⏳ CSSスタイリング（未実装）

使用した技術:
- React (useState)
- 配列メソッド: filter(), reduce(), map()
- toLocaleString()（数値フォーマット）
- 算術演算（減算）

## 学習メモ

### filter()とreduce()を組み合わせた合計計算

#### 収入の合計を計算する流れ

```jsx
const totalIncome = transactions
  .filter(t => t.type === 'income')
  .reduce((sum, t) => sum + t.amount, 0)
```

**ステップバイステップの処理:**

1. **filter()で収入だけを抽出:**
   ```jsx
   transactions.filter(t => t.type === 'income')
   // 例: [
   //   { id: 1, type: 'income', amount: 300000, ... },
   //   { id: 2, type: 'income', amount: 50000, ... }
   // ]
   ```

2. **reduce()で金額を合計:**
   ```jsx
   .reduce((sum, t) => sum + t.amount, 0)
   // 初期値: sum = 0
   // 1回目: sum = 0 + 300000 = 300000
   // 2回目: sum = 300000 + 50000 = 350000
   // 結果: 350000
   ```

#### 支出の合計も同様に計算

```jsx
const totalExpense = transactions
  .filter(t => t.type === 'expense')
  .reduce((sum, t) => sum + t.amount, 0)
```

- `t.type === 'expense'`で支出のみを抽出
- 同じくreduce()で合計を計算

#### 残高の計算

```jsx
const balance = totalIncome - totalExpense
```

- 収入合計から支出合計を引くだけ
- シンプルな算術演算

### reduce()メソッドの詳細説明

#### 基本構文

```jsx
array.reduce((accumulator, currentValue) => {
  // accumulatorを更新して返す
  return newAccumulator
}, initialValue)
```

**パラメータ:**
- `accumulator`（累積値）: 前回の処理結果を保持
- `currentValue`（現在の値）: 今処理中の配列要素
- `initialValue`（初期値）: accumulatorの最初の値

#### 具体例で理解する

```jsx
const numbers = [1, 2, 3, 4, 5]
const sum = numbers.reduce((acc, num) => acc + num, 0)

// 処理の流れ:
// 初期: acc = 0
// 1回目: acc = 0 + 1 = 1
// 2回目: acc = 1 + 2 = 3
// 3回目: acc = 3 + 3 = 6
// 4回目: acc = 6 + 4 = 10
// 5回目: acc = 10 + 5 = 15
// 結果: 15
```

#### 家計簿アプリでの使用例

```jsx
const transactions = [
  { id: 1, type: 'income', amount: 100000 },
  { id: 2, type: 'expense', amount: 3000 },
  { id: 3, type: 'income', amount: 50000 }
]

// 全取引の合計
const total = transactions.reduce((sum, t) => sum + t.amount, 0)
// 結果: 153000

// 収入だけの合計
const income = transactions
  .filter(t => t.type === 'income')
  .reduce((sum, t) => sum + t.amount, 0)
// 結果: 150000
```

### toLocaleString()による数値フォーマット

#### 使い方

```jsx
const amount = 1234567
console.log(amount.toLocaleString())  // "1,234,567"
```

#### JSX内での使用

```jsx
<div className="summary-amount">
  +{totalIncome.toLocaleString()}円
</div>
// 表示例: +350,000円
```

**メリット:**
- 大きな数値が読みやすくなる
- 自動的に3桁ごとにカンマが入る
- 金額表示の標準的な方法

#### 符号付き表示

```jsx
// 収入: プラス記号
<div className="summary-amount">+{totalIncome.toLocaleString()}円</div>

// 支出: マイナス記号
<div className="summary-amount">-{totalExpense.toLocaleString()}円</div>

// 残高: 符号なし（正負どちらもあり得る）
<div className="summary-amount">{balance.toLocaleString()}円</div>
```

### サマリーUIの構造

```jsx
<div className="summary">
  <div className="summary-item income">
    <div className="summary-label">収入</div>
    <div className="summary-amount">+{totalIncome.toLocaleString()}円</div>
  </div>
  <div className="summary-item expense">
    <div className="summary-label">支出</div>
    <div className="summary-amount">-{totalExpense.toLocaleString()}円</div>
  </div>
  <div className="summary-item balance">
    <div className="summary-label">残高</div>
    <div className="summary-amount">{balance.toLocaleString()}円</div>
  </div>
</div>
```

**構造の特徴:**
- 3つのsummary-item（収入、支出、残高）
- 各itemにはlabelとamountの2つの要素
- income/expense/balanceのクラス名で色分け（CSS用）

### なぜfilter()の後にreduce()を使うのか

#### パターン1: filter() + reduce()
```jsx
// 条件に合うデータの合計を計算
const totalIncome = transactions
  .filter(t => t.type === 'income')
  .reduce((sum, t) => sum + t.amount, 0)
```

#### パターン2: reduce()だけで条件分岐
```jsx
// reduce()内でif文を使う方法もある
const totalIncome = transactions.reduce((sum, t) => {
  if (t.type === 'income') {
    return sum + t.amount
  }
  return sum
}, 0)
```

**filter() + reduce()のメリット:**
- 処理が分かりやすい（フィルタリング→集計）
- コードが読みやすい
- それぞれのメソッドが1つの仕事だけをする（単一責任の原則）

**reduce()だけのデメリット:**
- 1つの関数で2つの処理（条件判定と合計）をしている
- コードが複雑になりやすい

### 計算結果を変数に格納するメリット

```jsx
// 変数に格納
const totalIncome = transactions
  .filter(t => t.type === 'income')
  .reduce((sum, t) => sum + t.amount, 0)

const totalExpense = transactions
  .filter(t => t.type === 'expense')
  .reduce((sum, t) => sum + t.amount, 0)

const balance = totalIncome - totalExpense
```

**メリット:**
1. **再利用可能**: 複数の場所で同じ値を使える
2. **パフォーマンス**: 計算は1回だけ（JSX内で何度書いても再計算されない）
3. **可読性**: 変数名で意味が明確になる
4. **保守性**: 計算ロジックを1箇所で管理

**もしJSX内で直接書いたら:**
```jsx
// これはやらない（非推奨）
<div>{transactions.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0)}</div>
```
- 長すぎて読みにくい
- 複数回使うと毎回再計算される可能性

## 重要な概念の整理

### 配列メソッドの使い分け

| メソッド | 目的 | 返り値 | 使用例 |
|---------|------|--------|--------|
| `filter()` | 条件に合う要素を抽出 | 新しい配列 | 収入だけを抽出 |
| `map()` | 各要素を変換 | 新しい配列 | UIコンポーネントの生成 |
| `reduce()` | 配列を1つの値にまとめる | 任意の値 | 合計金額の計算 |

### よく使う組み合わせパターン

1. **filter() + map()**: 条件に合う要素をUIに表示
   ```jsx
   transactions
     .filter(t => t.type === 'income')
     .map(t => <div key={t.id}>{t.amount}</div>)
   ```

2. **filter() + reduce()**: 条件に合う要素の合計
   ```jsx
   transactions
     .filter(t => t.type === 'income')
     .reduce((sum, t) => sum + t.amount, 0)
   ```

3. **map()だけ**: 全要素をUIに表示
   ```jsx
   transactions.map(t => <div key={t.id}>{t.amount}</div>)
   ```

### 家計簿アプリで学べる実践的なスキル

1. **データの集計**: filter() + reduce()
2. **条件付き表示**: 三項演算子、&&演算子
3. **動的なカテゴリ**: typeに応じた配列の切り替え
4. **フォーム管理**: 複数のstateによる入力管理
5. **リスト表示**: mapによる繰り返し表示
6. **CRUD操作**: Create（追加）、Read（表示）、Delete（削除）

## コードの動作確認

### テストシナリオ

1. **収入を追加:**
   - 種類: 収入
   - カテゴリ: 給与
   - 金額: 300000
   - → サマリーの「収入」が+300,000円と表示される
   - → 残高が300,000円と表示される

2. **支出を追加:**
   - 種類: 支出
   - カテゴリ: 食費
   - 金額: 3000
   - → サマリーの「支出」が-3,000円と表示される
   - → 残高が297,000円と表示される

3. **複数の取引を追加:**
   - 収入と支出を複数追加
   - → それぞれの合計が正しく計算される
   - → 残高 = 収入合計 - 支出合計

### 動作の確認ポイント

- [ ] 収入を追加すると収入の合計が増える
- [ ] 支出を追加すると支出の合計が増える
- [ ] 残高が正しく計算される（収入 - 支出）
- [ ] 金額が3桁区切りで表示される
- [ ] 収入は+、支出は-の符号が付く

## 次のステップ

- [ ] 月ごとの表示フィルタリング機能を実装
- [ ] LocalStorageでのデータ永続化
- [ ] CSSスタイリング（色分け、レイアウト）
- [ ] 削除機能の動作確認（バグ修正: transaction.idではなくt.id）
- [ ] カテゴリ別の集計機能（オプション）
- [ ] グラフ表示機能（オプション）
